import { createServer } from "http";
import { parse } from "url";
import next from "next";
import { Server } from "socket.io";
import OpenAI from "openai";
import dotenv from "dotenv";

// Load environment variables from .env file
dotenv.config();

const dev = process.env.NODE_ENV !== "production";
const hostname = "localhost";
const port = process.env.PORT || 3000;

// In-memory message storage
const messageStore = new Map();

// User violation tracking for AI context
const userViolations = new Map(); // roomId -> { username: violationCount }

// Room management for 2-person debates
const roomParticipants = new Map(); // roomId -> { participants: [], currentTurn: 0, debateStarted: false }
const roomConfigs = new Map(); // roomId -> { description, toleranceLevel, duration }
const turnTimers = new Map(); // roomId -> { timer: Timeout, timeLeft: number }
const motionTimers = new Map(); // roomId -> { timer: Timeout, timeLeft: number }
const motionStates = new Map(); // roomId -> { waitingForMotion: boolean, lastIntervention: any }

// Initialize OpenAI client (primary AI)
const openai = process.env.OPENAI_API_KEY
  ? new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    })
  : null;

// AI Service - Simplified for debate moderation
class AIService {
  constructor() {
    this.openai = openai;
  }

  // Check if AI service is available
  isAvailable() {
    return this.openai !== null;
  }

  // AI call method for moderation
  async callAI(systemPrompt, userPrompt) {
    if (!this.isAvailable()) {
      throw new Error("OpenAI API not available");
    }

    const completion = await this.openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: userPrompt },
      ],
      temperature: 0.3,
      max_tokens: 500,
    });

    return completion.choices[0]?.message?.content;
  }

  // AI Moderation for debate system
  async moderateMessage(
    message,
    username,
    conversationHistory = [],
    userViolationCount = 0,
    debateConfig = null
  ) {
    // Build debate context
    let debateContext = "";
    if (debateConfig && debateConfig.description) {
      debateContext = `\n\nðŸŽ¯ CONTEXTO DEL DEBATE:\nTema: ${debateConfig.description}\nNivel de tolerancia: ${debateConfig.toleranceLevel}\nDuraciÃ³n: ${debateConfig.duration} minutos\n`;
      console.log("ðŸŽ¯ Using debate context:", debateConfig.description);
    } else {
      console.log("âš ï¸ No debate context available");
    }

    // Use custom system prompt if provided, otherwise use default
    const systemPrompt = debateConfig && debateConfig.customSystemPrompt 
      ? debateConfig.customSystemPrompt
      : `Quiero simular un debate.
TÃº eres un moderador IA. ${debateContext}

IMPORTANTE: Siempre responde ÃšNICAMENTE con JSON vÃ¡lido. No incluyas texto adicional, explicaciones, ni markdown code blocks. Solo el JSON puro.

Reglas del moderador

Solo intervienes en estos casos:

Malas palabras o groserÃ­as â†’ 1 punto negativo.

DesvÃ­o del tema â†’ 1 punto negativo.

InformaciÃ³n no veraz â†’ 1 punto negativo.

Siempre indica el tipo de punto negativo de forma clara:

ðŸš¨ Insultos: "Llamado de atenciÃ³n: lenguaje inapropiado. Mantengamos el respeto. -1 punto"

âš ï¸ DesvÃ­o del tema: "DesvÃ­o detectado: recuerda que el tema es [tema central]. -1 punto"

âŒ InformaciÃ³n no veraz: "Punto negativo: la afirmaciÃ³n no es correcta porque [explicaciÃ³n breve]. -1 punto"

Si ninguna regla aplica, no generes ningÃºn texto. Mantente completamente en silencio.

Niveles de tolerancia a insultos

Nivel 1 (tranquilo): se penalizan adjetivos fuertes y comentarios despectivos.

Nivel 2 (intermedio): se permiten adjetivos crÃ­ticos y frases fuertes, pero no ofensivas directas a la persona.

Nivel 3 (intenso): se aceptan expresiones mÃ¡s duras y despectivas hacia ideas o posturas, nunca insultos directos a la persona ni groserÃ­as.

Si los participantes eligen niveles diferentes, se aplicarÃ¡ el menor de los nÃºmeros dichos.

Turnos

DespuÃ©s de cualquier intervenciÃ³n vÃ¡lida del moderador (punto negativo o mociÃ³n), indica quiÃ©n continÃºa:

Si la intervenciÃ³n fue sobre PERSONA 1 â†’ "ContinÃºa PERSONA 2"

Si la intervenciÃ³n fue sobre PERSONA 2 â†’ "ContinÃºa PERSONA 1"

MOCIÃ“N (solo aplica para informaciÃ³n no veraz)

Cuando un punto negativo sea asignado por informaciÃ³n no veraz, el participante puede solicitar una mociÃ³n.

FORMATO DE MOCIÃ“N: Los mensajes que comiencen con "mocion:" deben ser tratados como mociones. Ejemplo: "mocion:quiero aclarar que me referÃ­a a casos electivos"

Al recibir un mensaje en formato "mocion:[mensaje]", evalÃºa INMEDIATAMENTE la aclaraciÃ³n:

Si el punto negativo fue por insultos o desvÃ­o â†’ "No aplica mociÃ³n en este caso. ContinÃºa el debate."

Si el punto negativo fue por informaciÃ³n no veraz, evalÃºa la aclaraciÃ³n:

MOCIÃ“N vÃ¡lida:
"Se retira el punto negativo tras la aclaraciÃ³n. Sin embargo, se aclara que la afirmaciÃ³n inicial no es correcta: [explicaciÃ³n breve y tajante]. La palabra pasa al otro participante."

MOCIÃ“N no vÃ¡lida:
"La mociÃ³n no corrige el error. Se mantiene el punto negativo y se suma uno adicional. Â¿Deseas volver a aclarar la mociÃ³n? (Advertencia: puedes perder mÃ¡s puntos)."

La MOCIÃ“N solo puede explicarse una vez por cada punto negativo de informaciÃ³n no veraz.

Conteo de puntos y determinaciÃ³n del ganador

Cada vez que asignas un punto negativo, registra quiÃ©n lo recibiÃ³ y por quÃ© (tipo de punto negativo).

Cada vez que ocurre una mociÃ³n, ajusta los puntos segÃºn la decisiÃ³n.

Al final del debate, cuando los participantes escriban "ULTIMA INTERVENCION", haz un resumen final:

"Resumen final: [PERSONA 1]: [nÃºmero] puntos negativos. [PERSONA 2]: [nÃºmero] puntos negativos. Ganador: [PERSONA con menos puntos negativos]. Motivo de la victoria: [breve explicaciÃ³n del resultado]."

El ganador es quien tenga menos puntos negativos. Si hay empate, el ganador es quien haya tenido la Ãºltima palabra vÃ¡lida antes del resumen final.`;

    let response;

Solo intervienes en estos casos:

Malas palabras o groserÃ­as â†’ 1 punto negativo.

DesvÃ­o del tema â†’ 1 punto negativo.

InformaciÃ³n no veraz â†’ 1 punto negativo.

Siempre indica el tipo de punto negativo de forma clara:

ðŸš¨ Insultos: "Llamado de atenciÃ³n: lenguaje inapropiado. Mantengamos el respeto. -1 punto"

âš ï¸ DesvÃ­o del tema: "DesvÃ­o detectado: recuerda que el tema es [tema central]. -1 punto"

âŒ InformaciÃ³n no veraz: "Punto negativo: la afirmaciÃ³n no es correcta porque [explicaciÃ³n breve]. -1 punto"

Si ninguna regla aplica, no generes ningÃºn texto. Mantente completamente en silencio.

Niveles de tolerancia a insultos

Nivel 1 (tranquilo): se penalizan adjetivos fuertes y comentarios despectivos.

Nivel 2 (intermedio): se permiten adjetivos crÃ­ticos y frases fuertes, pero no ofensivas directas a la persona.

Nivel 3 (intenso): se aceptan expresiones mÃ¡s duras y despectivas hacia ideas o posturas, nunca insultos directos a la persona ni groserÃ­as.

Si los participantes eligen niveles diferentes, se aplicarÃ¡ el menor de los nÃºmeros dichos.

Turnos

DespuÃ©s de cualquier intervenciÃ³n vÃ¡lida del moderador (punto negativo o mociÃ³n), indica quiÃ©n continÃºa:

Si la intervenciÃ³n fue sobre PERSONA 1 â†’ "ContinÃºa PERSONA 2"

Si la intervenciÃ³n fue sobre PERSONA 2 â†’ "ContinÃºa PERSONA 1"

MOCIÃ“N (solo aplica para informaciÃ³n no veraz)

Cuando un punto negativo sea asignado por informaciÃ³n no veraz, el participante puede solicitar una mociÃ³n.

FORMATO DE MOCIÃ“N: Los mensajes que comiencen con "mocion:" deben ser tratados como mociones. Ejemplo: "mocion:quiero aclarar que me referÃ­a a casos electivos"

Al recibir un mensaje en formato "mocion:[mensaje]", evalÃºa INMEDIATAMENTE la aclaraciÃ³n:

Si el punto negativo fue por insultos o desvÃ­o â†’ "No aplica mociÃ³n en este caso. ContinÃºa el debate."

Si el punto negativo fue por informaciÃ³n no veraz, evalÃºa la aclaraciÃ³n:

MOCIÃ“N vÃ¡lida:
"Se retira el punto negativo tras la aclaraciÃ³n. Sin embargo, se aclara que la afirmaciÃ³n inicial no es correcta: [explicaciÃ³n breve y tajante]. La palabra pasa al otro participante."

MOCIÃ“N no vÃ¡lida:
"La mociÃ³n no corrige el error. Se mantiene el punto negativo y se suma uno adicional. Â¿Deseas volver a aclarar la mociÃ³n? (Advertencia: puedes perder mÃ¡s puntos)."

La MOCIÃ“N solo puede explicarse una vez por cada punto negativo de informaciÃ³n no veraz.

Conteo de puntos y determinaciÃ³n del ganador

Cada vez que asignas un punto negativo, registra quiÃ©n lo recibiÃ³ y por quÃ© (tipo de punto negativo).

Cada vez que ocurre una mociÃ³n, ajusta los puntos segÃºn la decisiÃ³n.

Al final del debate, cuando los participantes escriban "ULTIMA INTERVENCION", haz un resumen final:

Indica los puntos negativos totales por participante, especificando los motivos.

Declara el ganador (menos puntos negativos) o empate si son iguales.

Desarrollo del debate

El debate se desarrolla Ãºnicamente con las intervenciones de PERSONA 1 y PERSONA 2.

El moderador solo actÃºa en los casos indicados y sigue las reglas de mociÃ³n.

Si no hay acciÃ³n que tomar, no generes ningÃºn mensaje.`;

    // Build conversation context
    let conversationContext = "";
    if (conversationHistory.length > 0) {
      conversationContext = `\n\nRecent conversation context:\n${conversationHistory
        .slice(-10) // Last 10 messages for context
        .map((msg) => `${msg.username}: ${msg.message}`)
        .join("\n")}\n`;
    }

    // Build user context
    let userContext = "";
    if (userViolationCount > 0) {
      userContext = `\n\nUser Context: ${username} has ${userViolationCount} previous violation(s) in this room.`;
    }

    const userPrompt = `Analiza este mensaje de "${username}": "${message}"${conversationContext}${userContext}

CRÃTICO: Responde ÃšNICAMENTE con JSON vÃ¡lido. NO uses markdown, NO incluyas texto adicional, NO uses \`\`\`json\`\`\`. Solo el JSON puro.

Formato JSON requerido:
{
  "shouldRespond": true/false,
  "response": "tu mensaje de moderaciÃ³n si shouldRespond es true",
  "reason": "breve razÃ³n de la decisiÃ³n"
}

Solo responde si el mensaje viola claramente las reglas del debate (insultos, desvÃ­o del tema, informaciÃ³n no veraz, MOCIÃ“N, o ULTIMA INTERVENCION). Si no hay violaciÃ³n, shouldRespond debe ser false.`;

    let response;
    try {
      response = await this.callAI(systemPrompt, userPrompt);
      console.log("ðŸ¤– Raw AI response:", response);

      if (!response || response.trim() === "") {
        console.log("âš ï¸ Empty AI response received");
        return { shouldRespond: false };
      }

      // Clean response - remove markdown code blocks if present
      let cleanResponse = response.trim();
      if (cleanResponse.startsWith("```json")) {
        cleanResponse = cleanResponse
          .replace(/^```json\s*/, "")
          .replace(/\s*```$/, "");
      } else if (cleanResponse.startsWith("```")) {
        cleanResponse = cleanResponse
          .replace(/^```\s*/, "")
          .replace(/\s*```$/, "");
      }

      const parsed = JSON.parse(cleanResponse);
      return {
        shouldRespond: parsed.shouldRespond || false,
        response: parsed.response,
        reason: parsed.reason,
      };
    } catch (error) {
      console.error("AI Moderation error:", error);
      console.error("Failed to parse response:", response);
      return { shouldRespond: false };
    }
  }
}

// Initialize AI Service
const aiService = new AIService();

// Turn timer management functions (will be defined inside app.prepare() where io is available)

// Simple moderation function using the AI service
async function analyzeMessage(message, username, roomId) {
  if (!aiService.isAvailable()) {
    console.log("AI Moderation disabled: No OpenAI API key provided");
    return { shouldRespond: false };
  }

  try {
    console.log("ðŸ¤– AI analyzing message with context...");

    // Get conversation history for context
    const conversationHistory = messageStore.get(roomId) || [];

    // Get user violation count for this room
    const roomViolations = userViolations.get(roomId) || {};
    const userViolationCount = roomViolations[username] || 0;

    // Get debate config for context
    const debateConfig = roomConfigs.get(roomId);

    const result = await aiService.moderateMessage(
      message,
      username,
      conversationHistory,
      userViolationCount,
      debateConfig
    );

    // If AI responded, increment violation count
    if (result.shouldRespond) {
      roomViolations[username] = (roomViolations[username] || 0) + 1;
      userViolations.set(roomId, roomViolations);
      console.log(
        `ðŸ“Š User ${username} violation count: ${roomViolations[username]}`
      );
    }

    console.log(`âœ… AI analysis complete`);
    return result;
  } catch (error) {
    console.error("AI Moderation error:", error);
    return { shouldRespond: false };
  }
}

const app = next({ dev, hostname, port });
const handler = app.getRequestHandler();

app.prepare().then(() => {
  const httpServer = createServer((req, res) => {
    const parsedUrl = parse(req.url, true);
    handler(req, res, parsedUrl);
  });

  const io = new Server(httpServer, {
    cors: {
      origin: ["http://localhost:3000", "http://127.0.0.1:3000"],
      methods: ["GET", "POST"],
      credentials: true,
    },
    allowEIO3: true,
  });

  // Turn timer management functions (defined here where io is available)
  function startTurnTimer(roomId) {
    console.log(`â° Starting turn timer for room ${roomId}`);

    // Clear existing timer if any
    clearTurnTimer(roomId);

    // Start new timer (60 seconds)
    const timer = setTimeout(() => {
      console.log(`â° Turn timer expired for room ${roomId}`);
      switchToNextTurn(roomId);
    }, 60000); // 1 minute = 60,000ms

    // Start countdown updates every second
    const countdownInterval = setInterval(() => {
      const timerInfo = turnTimers.get(roomId);
      if (timerInfo) {
        timerInfo.timeLeft--;

        // Emit countdown update to room
        io.to(roomId).emit("turn-time-update", {
          timeLeft: timerInfo.timeLeft,
          roomId: roomId,
        });

        if (timerInfo.timeLeft <= 0) {
          clearInterval(countdownInterval);
        }
      } else {
        clearInterval(countdownInterval);
      }
    }, 1000);

    // Store timer info (including the countdown interval)
    turnTimers.set(roomId, {
      timer: timer,
      countdownInterval: countdownInterval,
      timeLeft: 60,
      startTime: Date.now(),
    });
  }

  function clearTurnTimer(roomId) {
    const timerInfo = turnTimers.get(roomId);
    if (timerInfo) {
      clearTimeout(timerInfo.timer);
      if (timerInfo.countdownInterval) {
        clearInterval(timerInfo.countdownInterval);
      }
      turnTimers.delete(roomId);
      console.log(`â° Cleared turn timer for room ${roomId}`);
    }
  }

  function clearMotionTimer(roomId) {
    const timerInfo = motionTimers.get(roomId);
    if (timerInfo) {
      clearTimeout(timerInfo.timer);
      if (timerInfo.countdownInterval) {
        clearInterval(timerInfo.countdownInterval);
      }
      motionTimers.delete(roomId);
      console.log(`â° Cleared motion timer for room ${roomId}`);
    }
  }

  function startMotionTimer(roomId) {
    console.log(`â° Starting motion timer for room ${roomId}`);

    // Clear existing motion timer if any
    clearMotionTimer(roomId);

    // Start new timer (15 seconds)
    const timer = setTimeout(() => {
      console.log(`â° Motion timer expired for room ${roomId}`);
      handleMotionTimeout(roomId);
    }, 15000); // 15 seconds

    // Start countdown updates every second
    const countdownInterval = setInterval(() => {
      const timerInfo = motionTimers.get(roomId);
      if (timerInfo) {
        timerInfo.timeLeft--;

        // Emit countdown update to room
        io.to(roomId).emit("motion-time-update", {
          timeLeft: timerInfo.timeLeft,
          roomId: roomId,
        });

        if (timerInfo.timeLeft <= 0) {
          clearInterval(countdownInterval);
        }
      } else {
        clearInterval(countdownInterval);
      }
    }, 1000);

    // Store timer info
    motionTimers.set(roomId, {
      timer: timer,
      countdownInterval: countdownInterval,
      timeLeft: 15,
      startTime: Date.now(),
    });
  }

  function handleMotionTimeout(roomId) {
    console.log(
      `â° Motion timeout for room ${roomId} - user accepted AI intervention, proceeding to next turn`
    );

    // Clear motion state
    motionStates.delete(roomId);

    // Notify clients that motion state is cleared
    io.to(roomId).emit("motion-state-update", {
      waitingForMotion: false,
      roomId: roomId,
    });

    // Continue to next turn (user accepted AI intervention by not requesting motion)
    switchToNextTurn(roomId);
  }

  function switchToNextTurn(roomId) {
    console.log(`ðŸ”„ Switching to next turn in room ${roomId}`);

    const roomData = roomParticipants.get(roomId);
    if (!roomData || !roomData.debateStarted) {
      console.log(
        `âš ï¸ Cannot switch turn - room ${roomId} not found or debate not started`
      );
      return;
    }

    // Switch to next participant
    roomData.currentTurn =
      (roomData.currentTurn + 1) % roomData.participants.length;
    roomData.currentSpeaker =
      roomData.participants[roomData.currentTurn].username;

    console.log(
      `ðŸ”„ Turn switched to: ${roomData.currentSpeaker} in room ${roomId}`
    );

    // Emit turn update to room
    io.to(roomId).emit("room-updated", {
      participants: roomData.participants,
      currentTurn: roomData.currentTurn,
      currentSpeaker: roomData.currentSpeaker,
      debateStarted: roomData.debateStarted,
    });

    // Start timer for new turn
    startTurnTimer(roomId);

    // Emit turn timeout message
    io.to(roomId).emit("message", {
      id: Date.now(),
      username: "Moderador",
      content: `â° Tiempo agotado. ContinÃºa ${roomData.currentSpeaker}`,
      timestamp: new Date().toISOString(),
      isOwn: false,
    });
  }

  io.on("connection", (socket) => {
    console.log("User connected:", socket.id);

    // Join a room
    socket.on("join-room", (data) => {
      const { roomId, username, debateConfig } = data;

      console.log("\n=== JOIN ROOM EVENT ===");
      console.log("Room ID:", roomId);
      console.log("Username:", username);
      console.log("Debate Config:", JSON.stringify(debateConfig, null, 2));
      console.log("Socket ID:", socket.id);

      // Check if room exists and has participants
      let roomData = roomParticipants.get(roomId) || {
        participants: [],
        currentTurn: 0,
        debateStarted: false,
      };

      console.log("Current room data:", JSON.stringify(roomData, null, 2));
      console.log("Total rooms in memory:", roomParticipants.size);
      console.log("All room IDs:", Array.from(roomParticipants.keys()));
      console.log(
        "All room configs:",
        JSON.stringify(Object.fromEntries(roomConfigs), null, 2)
      );

      // Check if room is full (2 participants max)
      if (roomData.participants.length >= 2) {
        console.log("Room is full, rejecting join");
        socket.emit("room-full", {
          message: "Room is full. Only 2 participants allowed.",
        });
        return;
      }

      // Check if this socket is already in the room
      if (roomData.participants.some((p) => p.socketId === socket.id)) {
        console.log("Socket already in room, ignoring duplicate join");
        return;
      }

      // Check if username already exists in room
      if (roomData.participants.some((p) => p.username === username)) {
        console.log("Username already taken, rejecting join");
        socket.emit("username-taken", {
          message: "Username already taken in this room.",
        });
        return;
      }

      // Add participant to room
      const participant = { socketId: socket.id, username: username };
      roomData.participants.push(participant);
      roomParticipants.set(roomId, roomData);

      // Store room config if this is the first participant
      if (roomData.participants.length === 1 && debateConfig) {
        console.log(
          "Storing room config for new room:",
          JSON.stringify(debateConfig, null, 2)
        );
        roomConfigs.set(roomId, debateConfig);
      }

      socket.join(roomId);
      console.log(`User ${username} (${socket.id}) joined room ${roomId}`);
      console.log("Updated room data:", JSON.stringify(roomData, null, 2));
      console.log(
        "Updated room configs:",
        JSON.stringify(Object.fromEntries(roomConfigs), null, 2)
      );

      // Send message history to the newly joined user
      if (messageStore.has(roomId)) {
        const messages = messageStore.get(roomId);
        console.log("Sending message history:", messages.length, "messages");
        socket.emit("message-history", messages);
      } else {
        console.log("No message history for room");
      }

      // Send room info to all participants
      const roomInfo = {
        participants: roomData.participants,
        currentTurn: roomData.currentTurn,
        currentSpeaker:
          roomData.participants[roomData.currentTurn]?.username || null,
        debateStarted: roomData.debateStarted,
      };

      console.log(
        "Sending room info to all participants:",
        JSON.stringify(roomInfo, null, 2)
      );

      // Send debate config to the newly joined user if room already has config
      const existingConfig = roomConfigs.get(roomId);
      console.log(
        `Room ${roomId} existing config:`,
        JSON.stringify(existingConfig, null, 2)
      );
      if (existingConfig) {
        console.log(`Sending config to user ${username} (${socket.id})`);
        socket.emit("room-config", existingConfig);
      } else {
        console.log(
          `No config found for room ${roomId}, waiting for creator...`
        );
        // Send a signal that we're waiting for the room creator
        socket.emit("waiting-for-creator", {
          message: "Waiting for room creator to join...",
        });
      }

      io.to(roomId).emit("room-updated", roomInfo);
      socket
        .to(roomId)
        .emit("user-joined", { socketId: socket.id, username: username });

      console.log("=== END JOIN ROOM EVENT ===\n");
    });

    // Send message to room
    socket.on("send-message", async (data) => {
      const roomData = roomParticipants.get(data.roomId);

      // Check if debate has started and if it's the user's turn
      if (roomData && roomData.participants.length === 2) {
        if (!roomData.debateStarted) {
          socket.emit("debate-not-started", {
            message: "The debate hasn't started yet.",
          });
          return;
        }

        const currentSpeaker = roomData.participants[roomData.currentTurn];
        if (currentSpeaker.socketId !== socket.id) {
          socket.emit("not-your-turn", {
            message: "It's not your turn to speak.",
            currentSpeaker: currentSpeaker.username,
          });
          return;
        }
      }

      const messageData = {
        id: Date.now().toString(),
        message: data.message,
        username: data.username,
        timestamp: new Date().toISOString(),
        socketId: socket.id,
        isAIModerator: false,
      };

      // Store message
      if (!messageStore.has(data.roomId)) {
        messageStore.set(data.roomId, []);
      }
      const messages = messageStore.get(data.roomId);
      messages.push(messageData);

      // Keep only last 100 messages per room
      if (messages.length > 100) {
        messages.splice(0, messages.length - 100);
      }
      messageStore.set(data.roomId, messages);

      // Broadcast original message to room FIRST
      io.to(data.roomId).emit("receive-message", messageData);

      // Check for AI intervention before switching turns
      if (
        roomData &&
        roomData.participants.length === 2 &&
        roomData.debateStarted
      ) {
        // Analyze message with AI
        const aiResult = await analyzeMessage(
          data.message,
          data.username,
          data.roomId
        );

        if (aiResult.shouldRespond) {
          // AI intervened - DO NOT switch turns, keep current speaker and start motion timer
          console.log(
            `ðŸ¤– AI intervened for ${data.username}, keeping turn and starting motion timer`
          );

          // Keep the current turn (don't switch to next participant)
          // The current speaker stays the same and can request a motion

          // IMPORTANT: Update the room data to ensure the current speaker is correctly set
          roomData.currentSpeaker = data.username;
          roomParticipants.set(data.roomId, roomData);

          // Set motion state
          motionStates.set(data.roomId, {
            waitingForMotion: true,
            lastIntervention: aiResult,
            currentSpeaker: data.username,
          });

          console.log(
            "ðŸ“‹ Motion state set for:",
            data.username,
            "in room:",
            data.roomId
          );

          // Start motion timer (15 seconds)
          startMotionTimer(data.roomId);

          // Notify clients about motion state
          console.log("ðŸ“‹ Emitting motion-state-update:", {
            waitingForMotion: true,
            roomId: data.roomId,
          });
          io.to(data.roomId).emit("motion-state-update", {
            waitingForMotion: true,
            roomId: data.roomId,
          });

          // Also emit room-updated to ensure the current speaker is correctly set on client
          const roomInfo = {
            participants: roomData.participants,
            currentTurn: roomData.currentTurn,
            currentSpeaker: roomData.currentSpeaker,
            debateStarted: roomData.debateStarted,
          };
          console.log(
            "ðŸ“‹ Emitting room-updated to maintain turn:",
            JSON.stringify(roomInfo, null, 2)
          );
          io.to(data.roomId).emit("room-updated", roomInfo);

          // Send AI intervention message
          if (aiResult.response) {
            const aiMessage = {
              id: `ai-${Date.now()}`,
              message: aiResult.response,
              username: "Moderador",
              timestamp: new Date().toISOString(),
              socketId: "ai-moderator",
              isAIModerator: true,
              reason: aiResult.reason,
            };

            // Store AI message
            messages.push(aiMessage);
            messageStore.set(data.roomId, messages);

            // Broadcast AI message to room
            io.to(data.roomId).emit("receive-message", aiMessage);

            console.log(
              `AI Moderator responded to message from ${data.username}: ${aiResult.reason}`
            );
          }

          // IMPORTANT: Do NOT switch turns here - keep the current speaker
          // The turn will only switch after motion timeout or motion request
        } else {
          // No AI intervention - proceed with normal turn switch
          console.log(
            `ðŸ¤– No AI intervention for ${data.username}, switching turns`
          );

          // Clear current turn timer
          clearTurnTimer(data.roomId);

          // Switch to next participant
          roomData.currentTurn = (roomData.currentTurn + 1) % 2;
          roomData.currentSpeaker =
            roomData.participants[roomData.currentTurn].username;
          roomParticipants.set(data.roomId, roomData);

          // Start timer for new turn
          startTurnTimer(data.roomId);

          // Notify all participants about turn change
          const roomInfo = {
            participants: roomData.participants,
            currentTurn: roomData.currentTurn,
            currentSpeaker: roomData.currentSpeaker,
            debateStarted: roomData.debateStarted,
          };
          io.to(data.roomId).emit("room-updated", roomInfo);
        }
      }
    });

    // Start debate
    socket.on("start-debate", (data) => {
      console.log("\n=== START DEBATE EVENT ===");
      console.log("Room ID:", data.roomId);
      console.log("Username:", data.username);

      const roomData = roomParticipants.get(data.roomId);
      console.log("Room data:", JSON.stringify(roomData, null, 2));
      console.log(
        "All rooms:",
        JSON.stringify(Object.fromEntries(roomParticipants), null, 2)
      );

      // Only allow starting if there are exactly 2 participants and debate hasn't started
      if (
        roomData &&
        roomData.participants.length === 2 &&
        !roomData.debateStarted
      ) {
        console.log("Starting debate - conditions met");
        roomData.debateStarted = true;
        roomData.currentTurn = 0; // Start with first participant
        roomData.currentSpeaker =
          roomData.participants[roomData.currentTurn].username;
        roomParticipants.set(data.roomId, roomData);

        // Start turn timer for first participant
        startTurnTimer(data.roomId);

        // Notify all participants that debate has started
        const roomInfo = {
          participants: roomData.participants,
          currentTurn: roomData.currentTurn,
          currentSpeaker: roomData.currentSpeaker,
          debateStarted: roomData.debateStarted,
        };

        console.log(
          "Sending debate started event with room info:",
          JSON.stringify(roomInfo, null, 2)
        );
        io.to(data.roomId).emit("debate-started", roomInfo);
        io.to(data.roomId).emit("room-updated", roomInfo);

        console.log(
          `Debate started in room ${data.roomId} by ${data.username}`
        );
        console.log("=== END START DEBATE EVENT ===\n");
      } else {
        console.log("Cannot start debate - conditions not met");
        console.log("Room exists:", !!roomData);
        console.log("Participants count:", roomData?.participants?.length || 0);
        console.log("Debate started:", roomData?.debateStarted);
        socket.emit("start-debate-failed", {
          message:
            "Cannot start debate. Need exactly 2 participants and debate must not have started yet.",
        });
      }
    });

    // Handle motion request
    socket.on("request-motion", async (data) => {
      console.log("\n=== REQUEST MOTION EVENT ===");
      console.log("Room ID:", data.roomId);
      console.log("Username:", data.username);

      const roomData = roomParticipants.get(data.roomId);
      const motionState = motionStates.get(data.roomId);

      if (!roomData || !motionState || !motionState.waitingForMotion) {
        console.log("âš ï¸ Motion request invalid - no active motion state");
        return;
      }

      if (motionState.currentSpeaker !== data.username) {
        console.log("âš ï¸ Motion request invalid - not current speaker");
        return;
      }

      console.log("ðŸ“‹ Processing motion request from:", data.username);

      // Clear motion timer
      clearMotionTimer(data.roomId);

      // Clear motion state
      motionStates.delete(data.roomId);

      // Notify clients that motion state is cleared
      io.to(data.roomId).emit("motion-state-update", {
        waitingForMotion: false,
        roomId: data.roomId,
      });

      // Restart turn timer for 1 minute so user has time to write motion
      startTurnTimer(data.roomId);

      // DO NOT send "MOCIÃ“N" message to chat
      // DO NOT switch turns - keep current speaker
      // The user can now send a message in format "mocion:[mensaje]"

      console.log(
        "ðŸ“‹ Motion request processed - user can now send motion message with 1 minute timer"
      );

      console.log("=== END REQUEST MOTION EVENT ===\n");
    });

    // Handle disconnect
    socket.on("disconnect", () => {
      console.log("\n=== DISCONNECT EVENT ===");
      console.log("User disconnected:", socket.id);
      console.log(
        "Current rooms before disconnect:",
        JSON.stringify(Object.fromEntries(roomParticipants), null, 2)
      );
      console.log(
        "Current configs before disconnect:",
        JSON.stringify(Object.fromEntries(roomConfigs), null, 2)
      );

      // Remove participant from all rooms
      for (const [roomId, roomData] of roomParticipants.entries()) {
        const participantIndex = roomData.participants.findIndex(
          (p) => p.socketId === socket.id
        );
        if (participantIndex !== -1) {
          const participant = roomData.participants[participantIndex];
          console.log(
            `Removing participant ${participant.username} from room ${roomId}`
          );

          roomData.participants.splice(participantIndex, 1);

          // Adjust turn if needed
          if (roomData.currentTurn >= roomData.participants.length) {
            roomData.currentTurn = 0;
          }

          roomParticipants.set(roomId, roomData);

          // Notify remaining participants
          if (roomData.participants.length > 0) {
            console.log(
              `Room ${roomId} still has ${roomData.participants.length} participants`
            );
            const roomInfo = {
              participants: roomData.participants,
              currentTurn: roomData.currentTurn,
              currentSpeaker:
                roomData.participants[roomData.currentTurn]?.username || null,
              debateStarted: roomData.debateStarted,
            };
            io.to(roomId).emit("room-updated", roomInfo);
            io.to(roomId).emit("user-left", { username: participant.username });
          } else {
            console.log(`Room ${roomId} is now empty, cleaning up`);
            // Clean up empty room
            roomParticipants.delete(roomId);
            roomConfigs.delete(roomId);
            clearTurnTimer(roomId);
            clearMotionTimer(roomId);
            motionStates.delete(roomId);
          }

          console.log(
            "Updated rooms after disconnect:",
            JSON.stringify(Object.fromEntries(roomParticipants), null, 2)
          );
          console.log(
            "Updated configs after disconnect:",
            JSON.stringify(Object.fromEntries(roomConfigs), null, 2)
          );
          break;
        }
      }
      console.log("=== END DISCONNECT EVENT ===\n");
    });
  });

  httpServer
    .once("error", (err) => {
      console.error(err);
      process.exit(1);
    })
    .listen(port, () => {
      console.log(`> Ready on http://${hostname}:${port}`);
    });
});
